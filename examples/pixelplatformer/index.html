<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/main.css">
    <link rel="shortcut icon" href="images/web/favicon.ico" >
    <title>Pixel platformer</title>
</head>
<body>
    <div class="play js-play">
        <div class="play__game-title">
            <div>Pixel<br>platformer</div>
        </div>
        <div class="play__button js-play-button">Play</div>
    </div>
    <div class="controls js-controls">
        <div class="controls__arrows">
            <div class="controls__arrow controls-arrow--left js-controls-arrow-left"></div>
            <div class="controls__arrow controls-arrow--right js-controls-arrow-right"></div>
        </div>
        <div class="controls__buttons">
            <div class="controls__button controls__button--fire js-controls-button-fire"></div>
            <div class="controls__button controls__button--jump js-controls-button-jump"></div>
        </div>
    </div>
    <canvas id="field"></canvas>
    <script src="../../dist/elpy.min.js"></script>
    <script>
        function getOrientation() {
  if (typeof window === 'undefined') return undefined;
  var screen = window.screen;
  var orientation;

  // W3C spec implementation
  if (
    typeof window.ScreenOrientation === 'function' &&
    screen.orientation instanceof ScreenOrientation &&
    typeof screen.orientation.addEventListener == 'function' &&
    screen.orientation.onchange === null &&
    typeof screen.orientation.type === 'string'
  ) {
    orientation = screen.orientation;
  } else {
    orientation = createOrientation();
  }

  return orientation;
}

function createOrientation() {
  var orientationMap = {
    '90': 'landscape-primary',
    '-90': 'landscape-secondary',
    '0': 'portrait-primary',
    '180': 'portrait-secondary',
  };

  function ScreenOrientation() {}
  var or = new ScreenOrientation();

  var found = findDelegate(or);

  ScreenOrientation.prototype.addEventListener = delegate(
    'addEventListener',
    found.delegate,
    found.event
  );
  ScreenOrientation.prototype.dispatchEvent = delegate(
    'dispatchEvent',
    found.delegate,
    found.event
  );
  ScreenOrientation.prototype.removeEventListener = delegate(
    'removeEventListener',
    found.delegate,
    found.event
  );
  ScreenOrientation.prototype.lock = getLock();
  ScreenOrientation.prototype.unlock = getUnlock();

  Object.defineProperties(or, {
    onchange: {
      get: function () {
        return found.delegate['on' + found.event] || null;
      },
      set: function (cb) {
        found.delegate['on' + found.event] = wrapCallback(cb, or);
      },
    },
    type: {
      get: function () {
        var screen = window.screen;
        return (
          screen.msOrientation ||
          screen.mozOrientation ||
          orientationMap[window.orientation + ''] ||
          (getMql().matches ? 'landscape-primary' : 'portrait-primary')
        );
      },
    },
    angle: {
      value: 0,
    },
  });

  return or;
}

function delegate(fnName, delegateContext, eventName) {
  var that = this;
  return function delegated() {
    var args = Array.prototype.slice.call(arguments);
    var actualEvent = args[0].type ? args[0].type : args[0];
    if (actualEvent !== 'change') {
      return;
    }
    if (args[0].type) {
      args[0] = getOrientationChangeEvent(eventName, args[0]);
    } else {
      args[0] = eventName;
    }
    var wrapped = wrapCallback(args[1], that);
    if (fnName === 'addEventListener') {
      addTrackedListener(args[1], wrapped);
    }
    if (fnName === 'removeEventListener') {
      removeTrackedListener(args[1]);
    }
    args[1] = wrapped;
    return delegateContext[fnName].apply(delegateContext, args);
  };
}

var trackedListeners = [];
var originalListeners = [];

function addTrackedListener(original, wrapped) {
  var idx = originalListeners.indexOf(original);
  if (idx > -1) {
    trackedListeners[idx] = wrapped;
  } else {
    originalListeners.push(original);
    trackedListeners.push(wrapped);
  }
}

function removeTrackedListener(original) {
  var idx = originalListeners.indexOf(original);
  if (idx > -1) {
    originalListeners.splice(idx, 1);
    trackedListeners.splice(idx, 1);
  }
}

function wrapCallback(cb, orientation) {
  var idx = originalListeners.indexOf(cb);
  if (idx > -1) {
    return trackedListeners[idx];
  }
  return function wrapped(evt) {
    if (evt.target !== orientation) {
      defineValue(evt, 'target', orientation);
    }
    if (evt.currentTarget !== orientation) {
      defineValue(evt, 'currentTarget', orientation);
    }
    if (evt.type !== 'change') {
      defineValue(evt, 'type', 'change');
    }
    cb(evt);
  };
}

function getLock() {
  var err = 'lockOrientation() is not available on this device.';
  var delegateFn;
  var screen = window.screen;
  if (typeof screen.msLockOrientation == 'function') {
    delegateFn = screen.msLockOrientation.bind(screen);
  } else if (typeof screen.mozLockOrientation == 'function') {
    delegateFn = screen.mozLockOrientation.bind(screen);
  } else {
    delegateFn = function () {
      return false;
    };
  }

  return function lock(lockType) {
    var Promise = window.Promise;
    if (delegateFn(lockType)) {
      return Promise.resolve(lockType);
    } else {
      return Promise.reject(new Error(err));
    }
  };
}

function getUnlock() {
  var screen = window.screen;
  return (
    (screen.orientation &&
      screen.orientation.unlock.bind(screen.orientation)) ||
    (screen.msUnlockOrientation && screen.msUnlockOrientation.bind(screen)) ||
    (screen.mozUnlockOrientation && screen.mozUnlockOrientation.bind(screen)) ||
    function unlock() {
      return;
    }
  );
}

function findDelegate(orientation) {
  var events = [
    'orientationchange',
    'mozorientationchange',
    'msorientationchange',
  ];

  for (var i = 0; i < events.length; i++) {
    if (screen['on' + events[i]] === null) {
      return {
        delegate: screen,
        event: events[i],
      };
    }
  }

  if (typeof window.onorientationchange != 'undefined') {
    return {
      delegate: window,
      event: 'orientationchange',
    };
  }

  return {
    delegate: createOwnDelegate(orientation),
    event: 'change',
  };
}

function getOrientationChangeEvent(name, props) {
  var orientationChangeEvt;

  try {
    orientationChangeEvt = new Event(name, props);
  } catch (e) {
    orientationChangeEvt = { type: 'change' };
  }
  return orientationChangeEvt;
}

function createOwnDelegate(orientation) {
  var ownDelegate = Object.create({
    addEventListener: function addEventListener(evt, cb) {
      if (!this.listeners[evt]) {
        this.listeners[evt] = [];
      }
      if (this.listeners[evt].indexOf(cb) === -1) {
        this.listeners[evt].push(cb);
      }
    },
    dispatchEvent: function dispatchEvent(evt) {
      if (!this.listeners[evt.type]) {
        return;
      }
      this.listeners[evt.type].forEach(function (fn) {
        fn(evt);
      });
      if (typeof orientation.onchange == 'function') {
        orientation.onchange(evt);
      }
    },
    removeEventListener: function removeEventListener(evt, cb) {
      if (!this.listeners[evt]) {
        return;
      }
      var idx = this.listeners[evt].indexOf(cb);
      if (idx > -1) {
        this.listeners[evt].splice(idx, 1);
      }
    },
  });

  ownDelegate.listeners = {};

  var mql = getMql();

  if (mql && typeof mql.matches === 'boolean') {
    mql.addListener(function () {
      ownDelegate.dispatchEvent(getOrientationChangeEvent('change'));
    });
  }

  return ownDelegate;
}

function getMql() {
  if (typeof window.matchMedia != 'function') {
    return {};
  }
  return window.matchMedia('(orientation: landscape)');
}

function defineValue(obj, key, val) {
  Object.defineProperty(obj, key, {
    value: val,
  });
}
    </script>  
    <script>
        function loadGame() {
            const options = {
                engine: {
                    favicon: false
                },
                character: {
                    images: [
                        {
                            paths: ['images/characters/0/character_idle_0000.png'],
                            state: '0:idle'
                        },
                        {
                            paths: ['images/characters/0/character_right_0000.png', 'images/characters/0/character_right_0001.png'],
                            state: '0:move:right',
                            time: 100
                        },
                        {
                            paths: ['images/characters/0/character_left_0000.png', 'images/characters/0/character_left_0001.png'],
                            state: '0:move:left',
                            time: 100
                        },
                        {
                            paths: ['images/characters/0/character_right_0001.png'],
                            state: '0:jump:right'
                        },
                        {
                            paths: ['images/characters/0/character_left_0001.png'],
                            state: '0:jump:left'
                        },
                        {
                            paths: ['images/characters/1/character_idle_0000.png'],
                            state: '1:idle'
                        },
                        {
                            paths: ['images/characters/1/character_right_0000.png', 'images/characters/1/character_right_0001.png'],
                            state: '1:move:right',
                            time: 100
                        },
                        {
                            paths: ['images/characters/1/character_left_0000.png', 'images/characters/1/character_left_0001.png'],
                            state: '1:move:left',
                            time: 100
                        },
                        {
                            paths: ['images/characters/1/character_right_0001.png'],
                            state: '1:jump:right'
                        },
                        {
                            paths: ['images/characters/1/character_left_0001.png'],
                            state: '1:jump:left'
                        },
                        {
                            paths: ['images/characters/2/character_idle_0000.png'],
                            state: '2:idle'
                        },
                        {
                            paths: ['images/characters/2/character_right_0000.png', 'images/characters/2/character_right_0001.png'],
                            state: '2:move:right',
                            time: 100
                        },
                        {
                            paths: ['images/characters/2/character_left_0000.png', 'images/characters/2/character_left_0001.png'],
                            state: '2:move:left',
                            time: 100
                        },
                        {
                            paths: ['images/characters/2/character_right_0001.png'],
                            state: '2:jump:right'
                        },
                        {
                            paths: ['images/characters/2/character_left_0001.png'],
                            state: '2:jump:left'
                        }
                    ],
                    custom: {
                        slidingDelta: 0,
                        evolution: 0,
                        isMoving: true
                    }
                },
                enemy: {
                    images: [
                        {
                            paths: ['images/enemies/enemy_move_left_0.png'],
                            state: 'move:left'
                        },
                        {
                            paths: ['images/enemies/enemy_move_right_0.png'],
                            state: 'move:right'
                        }
                    ],
                    type: 'enemy',
                    custom: {
                        delta: -1,
                        moving: false
                    }
                },
                background: {
                    image: {
                        src: 'images/background/background_0000.png',
                        repeat: true
                    }
                },
                ground: {
                    image: {
                        src: 'images/tiles/ground.png',
                        repeat: true
                    },
                    type: 'ground'
                },
                box: {
                    image: 'images/tiles/box.png',
                    type: 'box'
                },
                pipeHole: {
                    image: 'images/tiles/pipeHole.png',
                    type: 'pipe-hole'
                },
                pipe: {
                    image: 'images/tiles/pipe.png',
                    type: 'pipe'
                },
                treasure: {
                    images: [
                        {
                            paths: ['images/treasure/treasure.png'],
                            state: 'full'
                        },
                        {
                            paths: ['images/treasure/treasure_empty.png'],
                            state: 'empty'
                        }
                    ],
                    type: 'treasure',
                    custom: {
                        hasCoin: true
                    }
                },
                coin: {
                    obstacle: false,
                    images: [
                        {
                            paths: ['images/tiles/coin_0.png', 'images/tiles/coin_1.png'],
                            state: 'rotate',
                            time: 100
                        }
                    ],
                },
                flagpoleTip: {
                    image: 'images/tiles/flagpoleTip.png'
                },
                flagpole: {
                    obstacle: false,
                    image: {
                        src: 'images/tiles/flagpole.png',
                        repeat: true
                    }
                },
                flag: {
                    images: [
                        {
                            paths: ['images/tiles/flag_up.png', 'images/tiles/flag_down.png'],
                            state: 'flutters',
                            time: 100
                        }
                    ]
                },
                bonus: {
                    images: [
                        {
                            paths: ['images/tiles/mushroom.png'],
                            state: 'mushroom'
                        },
                        {
                            paths: ['images/tiles/flower.png'],
                            state: 'flower'
                        }
                    ],
                    type: 'bonus',
                    custom: {
                        moving: false,
                        spawned: false,
                        delta: 1
                    }
                },
                fireball: {
                    images: [
                        {
                            paths: ['images/tiles/fireball.png'],
                            state: 'default'
                        },
                        {
                            paths: ['images/effects/explosion_0.png', 'images/effects/explosion_1.png', 'images/effects/explosion_2.png'],
                            state: 'destroy',
                            time: 100
                        }
                    ]
                },
                bigGreenMountain: {
                    image: 'images/tiles/big-green-mountain.png'
                },
                smallGreenMountain: {
                    image: 'images/tiles/small-green-mountain.png'
                },
                smallBush: {
                    image: 'images/tiles/bush_0.png'
                },
                mediumBush: {
                    image: 'images/tiles/bush_1.png'
                },
                largeBush: {
                    image: 'images/tiles/bush_2.png'
                }
            }

            const map = {
                objects: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 1, 5, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                ],
                background: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0],
                ]
            }

            const enums = {
                objects: {
                    box: 1,
                    enemy: 2,
                    pipeHole: 3,
                    pipe: 4,
                    treasure: 5
                },
                background: {
                    cloudLeft: 1,
                    cloudCenter: 2,
                    cloudRight: 3,
                    bigGreenMountain: 4,
                    smallGreenMountain: 5,
                    smallBush: 6,
                    mediumBush: 7,
                    largeBush: 8
                }
            }

            const UNIT = 24;
            const CHARACTER_JUMP_HEIGHT = 100;
            const CHARACTER_JUMP_REBOUND = 10;
            const CHARACTER_JUMP_MULTIPLIER = 0.5;
            const FALL_MULTIPLIER = 0.5;
            const TREASURE_JUMP_HEIGHT = 10;
            const TREASURE_JUMP_MULTIPLIER = 1;
            const TREASURE_FALL_MULTIPLIER = 0.3;
            const ENEMY_JUMP_MULTIPLIER = 1;
            const ENEMY_JUMP_HEIGHT = 20;
            const MUSHROOM_JUMP_MULTIPLIER = 1;
            const MUSHROOM_JUMP_HEIGHT = 20;
            const ENEMY_ROTATE = 180;
            const DESTROY_TIME_DELAY = 500;
            const COIN_JUMP_HEIGHT = 30;
            const MAX_FLAG_LOWERING_HEIGHT = 270;
            const SLIDING_DELTA_MAX_VALUE = 5;
            const SLIDING_DELTA_DEFAULT_VALUE = 1;
            const SLIDING_DELTA_STEP = 0.1;
            const TREASURE_WITH_BONUS = ['treasure-9-21'];
            const grounds = [];
            const obstacles = [];
            const MAX_MAP_LENGTH = (map.objects[0].length - 1) * UNIT;
            const elpy = new Elpy('#field', window.screen.width < 768 ? window.screen.width : 500, UNIT * 15, options.engine);
            const background = elpy.create('background', -10000, -10000, 20000, 20000, options.background);            
            const flag = createFlag();
            let isFlagLowered = false;
            let coinCounter = 0;

            elpy.add(background);

            loadHiddenObjectTextures();
            spawnBackgroundObjects();
            spawnObjects();
            spawnGround();
            
            const character = elpy.create('character', (Math.floor(elpy.width / UNIT) / 2) * UNIT, UNIT * 10, 20, UNIT, options.character);

            elpy.add(character);
            character.move(60, character.y);
            elpy.fixingCamera(character, {
                x: true
            });

            setObstaclesParams();

            character.collision(obstacles);
            character.collision(grounds);
            character.fall(FALL_MULTIPLIER);
            character.on('move', characterOnMove);
            character.on('collision', characterOnCollision);

            elpy.tick(() => {
                if (character.options.custom.slidingDelta > 0) {
                    character.options.custom.slidingDelta -= SLIDING_DELTA_STEP;

                    if (Math.floor(character.options.custom.slidingDelta) < 0) {
                        character.options.custom.slidingDelta = 0;
                    }
                }

                if (character.options.custom.slidingDelta < 0) {
                    character.options.custom.slidingDelta += SLIDING_DELTA_STEP;

                    if (Math.floor(character.options.custom.slidingDelta) > 0) {
                        character.options.custom.slidingDelta = 0;
                    }
                }

                character.move(character.x + Math.floor(character.options.custom.slidingDelta), character.y);
            });

            elpy.key(key => {
                if (!character.options.custom.isMoving) {
                    character.options.custom.slidingDelta = 0;

                    return;
                }

                switch(key) {
                    case 'ArrowUp':
                        character.jump(CHARACTER_JUMP_HEIGHT, CHARACTER_JUMP_MULTIPLIER);
                        
                        break;
                    case 'ArrowLeft':
                        if (character.options.custom.slidingDelta > -SLIDING_DELTA_MAX_VALUE) {
                            if (character.options.custom.slidingDelta === 0) {
                                character.options.custom.slidingDelta = -SLIDING_DELTA_DEFAULT_VALUE;
                            }

                            character.options.custom.slidingDelta -= SLIDING_DELTA_STEP * 2;
                        }
                        
                        break;
                    case 'ArrowRight':
                        if (character.options.custom.slidingDelta < SLIDING_DELTA_MAX_VALUE) {
                            if (character.options.custom.slidingDelta === 0) {
                                character.options.custom.slidingDelta = SLIDING_DELTA_DEFAULT_VALUE;
                            }

                            character.options.custom.slidingDelta += SLIDING_DELTA_STEP * 2;
                        }
                        
                        break;
                }
            });

            elpy.keydown(key => {
                switch(key) {
                    case 'ControlLeft':
                        if (character.options.custom.evolution === 2) {
                            fireball();
                        }

                        break;
                }
            })

            elpy.keyup(key => {
                switch(key) {
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        character.state = `${character.options.custom.evolution}:idle`;
                        character.animate = false;

                        break;
                }
            });

            elpy.load();

            function spawnBackgroundObjects() {
                for(let i = 0; i < map.objects.length; i++) {
                    for(let j = 0; j < map.objects[i].length; j++) {
                        if (map.background[i][j] === enums.background.bigGreenMountain) {
                            spawnBigGreenMountain(i, j);
                        }

                        if (map.background[i][j] === enums.background.smallGreenMountain) {
                            spawnSmallGreenMountain(i, j);
                        }

                        if (map.background[i][j] === enums.background.smallBush) {
                            spawnSmallBush(i, j);
                        }

                        if (map.background[i][j] === enums.background.mediumBush) {
                            spawnMediumBush(i, j);
                        }

                        if (map.background[i][j] === enums.background.largeBush) {
                            spawnLargeBush(i, j);
                        }
                    }
                }
            }

            function spawnObjects() {
                for(let i = 0; i < map.objects.length; i++) {
                    for(let j = 0; j < map.objects[i].length; j++) {
                        if (map.objects[i][j] === enums.objects.box) {
                            spawnBoxes(i, j);
                        }

                        if (map.objects[i][j] === enums.objects.enemy) {
                            spawnEnemies(i, j);
                        }

                        if (map.objects[i][j] === enums.objects.pipeHole) {
                            spawnPipeHoles(i, j);
                        }

                        if (map.objects[i][j] === enums.objects.pipe) {
                            spawnPipe(i, j);
                        }

                        if (map.objects[i][j] === enums.objects.treasure) {
                            spawnTreasures(i, j);
                        }

                        if (map.background[i][j] === enums.background.cloudLeft) {
                            spawnCloud('left', i, j);
                        }

                        if (map.background[i][j] === enums.background.cloudCenter) {
                            spawnCloud('center', i, j);
                        }

                        if (map.background[i][j] === enums.background.cloudRight) {
                            spawnCloud('right', i, j);
                        }
                    }
                }
            }

            function spawnBoxes(i, j) {
                const box = elpy.create(`box-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, options.box);
                            
                elpy.add(box);
                obstacles.push(box);
            }

            function spawnEnemies(i, j) {
                const enemy = elpy.create(`enemy-${i}-${j}`, UNIT * j, UNIT * i, 15, 13, JSON.parse(JSON.stringify(options.enemy)));
                
                elpy.add(enemy);
                obstacles.push(enemy);
                enemy.on('fall', event => {
                    enemyOnFall(enemy, event);
                });
            }

            function spawnPipeHoles(i, j) {
                const pipeHole = elpy.create(`pipe-hole-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, options.pipeHole);
                            
                elpy.add(pipeHole);
                obstacles.push(pipeHole);
            }

            function spawnPipe(i, j) {
                const pipe = elpy.create(`pipe-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, options.pipe);
                            
                elpy.add(pipe);
                obstacles.push(pipe);
            }

            function spawnTreasures(i, j) {
                const treasure = elpy.create(`treasure-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, JSON.parse(JSON.stringify(options.treasure)));

                elpy.add(treasure);
                obstacles.push(treasure);
                treasure.collision(getObstaclesEnemies());
                treasure.on('collision', object => {
                    if (object.options.type === 'enemy') {
                        treasureOnCollisionEnemy(treasure, object);
                    }

                    if (object.options.type === 'bonus' && object.state === 'mushroom' && object.options.custom.spawned) {
                        object.options.custom.delta = -object.options.custom.delta;
                        object.jump(MUSHROOM_JUMP_HEIGHT, MUSHROOM_JUMP_MULTIPLIER);
                        treasure.jump(TREASURE_JUMP_HEIGHT, TREASURE_JUMP_MULTIPLIER, true);
                    }
                });

                rebound(treasure, TREASURE_FALL_MULTIPLIER);
            }

            function spawnCloud(part, i, j) {
                const cloud = elpy.create(`cloud-${part}-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, {
                    image: `images/tiles/cloud-${part}.png`
                });
                
                elpy.add(cloud);
            }

            function spawnBigGreenMountain(i, j) {
                const bigGreenMountain = elpy.create(`big-green-mountain-${i}-${j}`, UNIT * j, (UNIT * i) - (UNIT / 2), 72, 72, options.bigGreenMountain);

                bigGreenMountain.rotate(45);
                elpy.add(bigGreenMountain);
            }

            function spawnSmallGreenMountain(i, j) {
                const smallGreenMountain = elpy.create(`small-green-mountain-${i}-${j}`, UNIT * j, (UNIT * i) + (UNIT / 2), 72, 72, options.smallGreenMountain);

                smallGreenMountain.rotate(45);
                elpy.add(smallGreenMountain);
            }

            function spawnSmallBush(i, j) {
                const smallBush = elpy.create(`small-bush-${i}-${j}`, UNIT * j, (UNIT * i) + 8, 42, 18, options.smallBush);

                elpy.add(smallBush);
            }

            function spawnMediumBush(i, j) {
                const mediumBush = elpy.create(`medium-bush-${i}-${j}`, UNIT * j, (UNIT * i) + 8, 62, 18, options.mediumBush);

                elpy.add(mediumBush);
            }

            function spawnLargeBush(i, j) {
                const largeBush = elpy.create(`large-bush-${i}-${j}`, UNIT * j, (UNIT * i) + 8, 82, 18, options.largeBush);

                elpy.add(largeBush);
            }

            function spawnGround() {
                const ground01 = elpy.create('ground01', 0, UNIT * 13, UNIT * 69, UNIT * 2, options.ground);
                const ground02 = elpy.create('ground02', UNIT * 71, UNIT * 13, UNIT * 15, UNIT * 2, options.ground);
                const ground03 = elpy.create('ground03', UNIT * 89, UNIT * 13, UNIT * 64, UNIT * 2, options.ground);
                const ground04 = elpy.create('ground04', UNIT * 155, UNIT * 13, UNIT * 69, UNIT * 2, options.ground);
                
                grounds.push(ground01);
                grounds.push(ground02);
                grounds.push(ground03);
                grounds.push(ground04);
                elpy.add(grounds);
            }

            function characterOnMove() {
                if (character.x > character.track.x) {
                    if (!character.animate) {
                        character.animate = true;
                    }

                    character.state = `${character.options.custom.evolution}:move:right`;
                    
                    if (character.isJumping) {
                        character.state = `${character.options.custom.evolution}:jump:right`;
                    }
                }

                if (character.x < character.track.x) {
                    if (!character.animate) {
                        character.animate = true;
                    }

                    character.state = `${character.options.custom.evolution}:move:left`;

                    if (character.isJumping) {
                        character.state = `${character.options.custom.evolution}:jump:left`;
                    }
                }

                if (character.x <= 0) {
                    character.move(character.x + 1, character.y);
                    
                    character.state = `${character.options.custom.evolution}:idle`;
                }

                if (character.x >= MAX_MAP_LENGTH) {
                    character.move(character.x - 1, character.y);
                    
                    character.state = `${character.options.custom.evolution}:idle`;
                }

                checkObstaclesInViewport();
            }

            function characterOnCollision(object, side) {
                character.state = `${character.options.custom.evolution}:idle`;

                if (['enemy', 'treasure', 'box', 'pipe', 'pipe-hole'].includes(object.options.type)
                && (side === 'left' || side === 'right')) {
                    character.options.custom.slidingDelta = 0;
                }

                if (object.options.type === 'enemy') {
                    checkEnemyCollision(object, side);
                }

                if (object.options.type === 'bonus') {
                    if (object.state === 'mushroom') {
                        object.destroy();
                        
                        characterGrowth(character.width * 2);
                    }

                    if (object.state === 'flower') {
                        object.destroy();

                        character.options.custom.evolution = 2;
                    }
                }

                //
                if ((object.name === 'treasure-9-21' || object.name === 'treasure-9-23')&& side === 'bottom' && object.state === 'full') {
                    if (character.options.custom.evolution === 0) {
                        mushroom();
                    }

                    if (character.options.custom.evolution === 1) {
                        flower();
                    }
                }

                function mushroom() {
                    const MAX_DISTANCE = UNIT / 2;
                    let traveledDistance  = 0;
                    const bonus = elpy.create(`bonus-${object.name}`, object.x + ((UNIT / 2) / 2), object.y, UNIT / 2, UNIT / 2, JSON.parse(JSON.stringify(options.bonus)));

                    object.options.custom.hasCoin = false;

                    checkTreasureCollision(object);
                    
                    bonus.collision(character);
                    bonus.collision(obstacles);
                    bonus.collision(grounds);
                    obstacles.forEach(obstacle => {
                        if (obstacle !== object) {
                            obstacle.collision(bonus);
                        }
                    });
                    obstacles.push(bonus);
                    character.collision(bonus);
                    elpy.add(bonus);
                    
                    elpy.tick(() => {
                        if (traveledDistance >= MAX_DISTANCE) {
                            bonus.fall(FALL_MULTIPLIER);

                            bonus.options.custom.spawned = true;

                            moveObstacle(bonus);

                            return false;
                        }

                        traveledDistance++;
                        
                        bonus.y -= 1;
                    });
                    
                    bonus.on('collision', (object, side) => {
                        if (object === character) {
                            bonus.destroy();

                            characterGrowth(character.width * 2);
                        }

                        if (side === 'left') {
                            bonus.options.custom.delta = -1;
                        }

                        if (side === 'right') {
                            bonus.options.custom.delta = 1;
                        }
                    });

                    bonus.on('move', () => {
                        if (bonus.y >= elpy.height) {
                            bonus.destroy();
                        }
                    });
                }

                function flower() {
                    const MAX_DISTANCE = UNIT / 2;
                    let traveledDistance  = 0;
                    const bonus = elpy.create(`bonus-${object.name}`, object.x + ((UNIT / 2) / 2), object.y, UNIT / 2, UNIT / 2, JSON.parse(JSON.stringify(options.bonus)));

                    object.options.custom.hasCoin = false;
                    
                    bonus.state = 'flower';
                    
                    character.collision(bonus);
                    elpy.add(bonus);

                    elpy.tick(() => {
                        if (traveledDistance >= MAX_DISTANCE) {
                            bonus.options.custom.spawned = true;

                            return false;
                        }

                        traveledDistance++;
                        
                        bonus.y -= 1;
                    });
                }
                //

                if (object.options.type === 'treasure' && side === 'bottom' && object.state === 'full') {
                    checkTreasureCollision(object);
                }

                if (object.name === 'flagpole') {
                    if (!isFlagLowered) {
                        isFlagLowered = true;

                        character.stop();

                        character.options.custom.isMoving = false;

                        lowerFlag();
                        lowerCharacter();
                    }
                }
            }

            function characterGrowth(value) {
                const offset = (value / 2) - (character.width / 2);
                
                elpy.offset.object.offset.x += offset;
                elpy.offset.x -= offset;
                character.y = character.y - character.height;
                character.height = character.height * 2;
                character.width = value;
                character.options.custom.evolution = 1;

                character.move(character.x - offset, character.y)
            }

            function enemyOnFall(enemy, event) {
                if (elpy.checkObjectInViewport(enemy)) {
                    event.resume();
                } else {
                    event.pause();
                }
                
                if (enemy.ghost) {
                    event.stop();
                }
            }

            function treasureOnCollisionEnemy(treasure, object) {
                object.ghost = true;
                
                object.jump(ENEMY_JUMP_HEIGHT, ENEMY_JUMP_MULTIPLIER);
                object.rotate(ENEMY_ROTATE);
                treasure.jump(TREASURE_JUMP_HEIGHT, TREASURE_JUMP_MULTIPLIER, true);
                
                delayedDestroy(object, DESTROY_TIME_DELAY);
            }

            function getObstaclesEnemies() {
                return obstacles.filter(obstacle => obstacle.options.type === 'enemy');
            }

            function setObstaclesParams() {
                obstacles.forEach(obstacle => {
                    if (obstacle.options.type === 'enemy') {
                        obstacle.on('collision', (object, side) => {
                            if (side === 'left') {
                                obstacle.options.custom.delta = -1;
                                obstacle.state = 'move:left';
                            }

                            if (side === 'right' || obstacle.x >= MAX_MAP_LENGTH) {
                                obstacle.options.custom.delta = 1;
                                obstacle.state = 'move:right';
                            }
                        });

                        obstacle.on('move', () => {
                            if (obstacle.y >= elpy.height) {
                                obstacle.destroy();
                            }
                        });

                        obstacle.collision(obstacles);
                        obstacle.collision(character);
                        obstacle.collision(grounds);
                        obstacle.fall(FALL_MULTIPLIER);
                    }
                });
            }

            function moveObstacle(obstacle) {
                if (!obstacle.options.custom.moving) {
                    obstacle.options.custom.moving = true;

                    elpy.tick(() => {
                        if (!elpy.checkObjectInViewport(obstacle) || obstacle.ghost) {
                            obstacle.options.custom.moving = false;

                            return false;
                        }

                        obstacle.move(obstacle.x + obstacle.options.custom.delta, obstacle.y);
                    });
                }
            }

            function checkObstaclesInViewport() {
                obstacles.forEach(obstacle => {
                    if (['enemy', 'bonus'].includes(obstacle.options.type)) {
                        if (elpy.checkObjectInViewport(obstacle)) {
                            moveObstacle(obstacle);
                        } else {
                            obstacle.options.custom.moving = false;
                        }
                    }
                });
            }

            function checkEnemyCollision(object, side) {
                if (side === 'top') {
                    elpy.nextTick(() => {
                        character.jump(CHARACTER_JUMP_REBOUND, CHARACTER_JUMP_MULTIPLIER);
                    });

                    const height = object.height / 2;

                    object.height = height;
                    object.y = object.y + height;
                    object.ghost = true;

                    delayedDestroy(object, DESTROY_TIME_DELAY);
                }
            }

            function checkTreasureCollision(object) {
                object.jump(TREASURE_JUMP_HEIGHT, TREASURE_JUMP_MULTIPLIER);

                object.state = 'empty';
                
                if (object.options.custom.hasCoin) {
                    dropCoin(object);
                }
            }

            function rebound(object, fallMultiplier = 0.1) {
                const y = object.y;

                object.on('fall', event => {
                    if (object.y >= y) {
                        object.move(object.x, y);
                        event.stop();
                    }
                });

                object.on('jump', event => {
                    if (object.y === object.track.y) {
                        event.stop();
                        object.fall(fallMultiplier)
                    }
                });
            }

            function dropCoin(object) {
                const coin = elpy.create('coin' + coinCounter, object.x + 3, object.y - object.height, 18, 18, options.coin);

                coinCounter++;

                coin.on('jump', event => {
                    if (coin.y === coin.track.y) {
                        event.stop();

                        delayedDestroy(coin, DESTROY_TIME_DELAY);
                    }
                });

                coin.animate = true;

                elpy.add(coin);
                coin.jump(COIN_JUMP_HEIGHT);
            }

            function delayedDestroy(object, time) {
                setTimeout(() => {
                    object.destroy();
                }, time);
            }

            function loadHiddenObjectTextures() {
                const coin = elpy.create('coin', 0, 0, 0, 0, options.coin);

                elpy.add(coin);
                elpy.on('load', () => {
                    coin.destroy();
                });
            }

            function createFlag() {
                const flagpoleTip = elpy.create('flagpole-tip', (UNIT * 198) + 9, (UNIT * 3), 6, 4, options.flagpoleTip);
                const flagpole = elpy.create('flagpole', (UNIT * 198) + 9, (UNIT * 3) + 4, 6, (UNIT * 9) - 4, options.flagpole);
                const flag = elpy.create('flag', (UNIT * 198) + 9, (UNIT * 3) + 4, 18, 18, options.flag);

                flag.animate = true;
                
                elpy.add(flagpoleTip);
                elpy.add(flagpole);
                elpy.add(flag);

                obstacles.push(flagpole);

                return flag;
            }

            function lowerFlag() {
                if (flag.y >= MAX_FLAG_LOWERING_HEIGHT) {
                    return;
                }

                let y = flag.y;

                elpy.tick(() => {
                    if (y >= MAX_FLAG_LOWERING_HEIGHT) {
                        return false;
                    }

                    flag.move(flag.x, y);

                    y += 2;
                })
            }
            
            function fireball() {
                const width = 16;
                const height = 16;
                const fireball = elpy.create('fireball', character.x + (character.width / 2), (character.y + (character.height / 2)) - (height / 2), width, height, options.fireball);

                fireball.collision(obstacles);
                fireball.collision(grounds);
                fireball.fall(0.5);
                elpy.add(fireball);

                fireball.on('collision', (object) => {
                    elpy.nextTick(() => {
                        if (object.options.type === 'enemy') {
                            //
                            fireball.stop();
                            
                            fireball.animate = true;
                            fireball.state = 'destroy';

                            delayedDestroy(fireball, 300);

                            object.ghost = true;

                            object.jump(5, ENEMY_JUMP_MULTIPLIER);
                            object.rotate(ENEMY_ROTATE);

                            delayedDestroy(object, DESTROY_TIME_DELAY);
                            //
                        }

                        if (object.options.type === 'ground') {
                            fireball.jump(5, 0.5);
                        } else {
                            fireball.stop();

                            fireball.animate = true;
                            fireball.state = 'destroy';

                            delayedDestroy(fireball, 300);
                        }
                    });
                });

                elpy.tick(() => {
                    if (fireball.state === 'destroy') {
                        return false;
                    }

                    if (fireball.state === 'default') {
                        fireball.rotate(fireball.degrees + 5);
                        fireball.move(fireball.x + 5, fireball.y);
                    }
                });
            }

            async function lowerCharacter() {
                removeCollisionWithCharacter();

                await moveCharacterDown();
                await moveCharacterRight();
                await moveCharacterToCastle();
            }

            function removeCollisionWithCharacter() {
                character.obstacles.forEach(obstacle => {
                    if (obstacle.name.includes('box')) {
                        character.removeCollision(obstacle);
                    }
                });
            }

            function moveCharacterDown() {
                return new Promise(resolve => {
                    elpy.tick(() => {
                        if (character.y >= 264) {
                            resolve();

                            return false;
                        }

                        character.move(character.x, character.y + 2);
                    });
                });
            }

            function moveCharacterRight() {
                return new Promise(resolve => {
                    elpy.tick(() => {
                        if (character.x >= 4766) {
                            resolve();

                            return false;
                        }

                        character.move(character.x + 1, character.y);
                    })
                });
            }

            function moveCharacterToCastle() {
                return new Promise(resolve => {
                    character.fall();
                    character.jump(10, 0.1, true);

                    elpy.tick(() => {
                        if (character.x >= 4898) {
                            resolve();
                            
                            return false;
                        }

                        character.move(character.x + 1, character.y);
                    });
                });
            }

            window._debug = function() {
                window._elpy = elpy;
                window._character = character;

                elpy.click((x, y) => {
                    const offset = {
                        x: x + elpy.offset.object.offset.x,
                        y: y + elpy.offset.object.offset.y
                    }

                    for(const name in elpy.objects) {
                        const object = elpy.objects[name];

                        if (offset.x > object.x
                        && offset.x < (object.x + object.width)
                        && offset.y > object.y
                        && offset.y < (object.y + object.height)) {
                            console.log(object)
                        }
                    }
                });
            }
        }

        init();

        function init() {
            if (window.screen.width <= 768) {
                if (window.screen.width > window.screen.height) {
                    location.reload(true);

                    return;
                }

                loadMobileGame();
            } else {
                loadGame();
            }
        }

        function loadMobileGame() {
            const field = document.querySelector('#field');
            const controls = document.querySelector('.js-controls');
            const controlsArrowLeft = document.querySelector('.js-controls-arrow-left');
            const controlsArrowRight = document.querySelector('.js-controls-arrow-right');
            const controlsButtonFire = document.querySelector('.js-controls-button-fire');
            const controlsButtonJump = document.querySelector('.js-controls-button-jump');
            const play = document.querySelector('.js-play');
            const playButton = document.querySelector('.js-play-button');
            
            controlsArrowLeft.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ArrowLeft'}));
            });

            controlsArrowLeft.addEventListener('touchend', () => {
                document.dispatchEvent(new KeyboardEvent('keyup',{'code':'ArrowLeft'}));
            });

            controlsArrowRight.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ArrowRight'}));
            });

            controlsArrowRight.addEventListener('touchend', () => {
                document.dispatchEvent(new KeyboardEvent('keyup',{'code':'ArrowRight'}));
            });

            controlsButtonFire.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ControlLeft'}));
            });

            controlsButtonJump.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ArrowUp'}));
            });

            controlsButtonJump.addEventListener('touchend', () => {
                document.dispatchEvent(new KeyboardEvent('keyup',{'code':'ArrowUp'}));
            });

            window.addEventListener('load', () => {
                const desiredWidth = Math.max(window.screen.width, window.screen.height);

                playButton.addEventListener('click', () => {
                    play.style.display = 'none';
                    
                    requestFullscreen(document.body);

                    window.addEventListener('fullscreenchange', () => {
                        const orientation = getOrientation();
                        orientation.lock("landscape-primary");
                        //screen.orientation.lock("landscape-primary");

                        const id = setInterval(() => {
                            if (screen.width === desiredWidth) {
                                play.style.display = 'none';
                                controls.style.display = 'flex';
                                field.style.display = 'block';
                            
                                clearInterval(id);
                                loadGame();
                            }
                        });
                    });
                });
            });

            function requestFullscreen(element) {
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.webkitRequestFullScreen) {
                    element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            }
        }
    </script>
</body>
</html>