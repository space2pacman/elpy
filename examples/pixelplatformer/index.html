<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/main.css">
    <title>Elpy.js</title>
</head>
<body>
    <div class="play js-play">
        <div class="play__button js-play-button">Play</div>
    </div>
    <div class="controls js-controls">
        <div class="controls__arrows">
            <div class="controls__arrow controls-arrow--left js-controls-arrow-left"></div>
            <div class="controls__arrow controls-arrow--right js-controls-arrow-right"></div>
        </div>
        <div class="controls__buttons">
            <div class="controls__button controls__button--jump js-controls-button-jump"></div>
        </div>
    </div>
    <canvas id="field"></canvas>
    <script src="../../dist/elpy.min.js"></script>
    <script>
        function init() {
            const options = {
                character: {
                    images: [
                        {
                            paths: ['images/characters/character_idle_0000.png'],
                            state: 'idle'
                        },
                        {
                            paths: ['images/characters/character_right_0000.png', 'images/characters/character_right_0001.png'],
                            state: 'move:right',
                            time: 100
                        },
                        {
                            paths: ['images/characters/character_left_0000.png', 'images/characters/character_left_0001.png'],
                            state: 'move:left',
                            time: 100
                        }
                    ],
                    custom: {
                        slidingDelta: 0,
                        isMoving: true
                    }
                },
                enemy: {
                    images: [
                        {
                            paths: ['images/enemies/enemy_move_left_0.png'],
                            state: 'move:left'
                        },
                        {
                            paths: ['images/enemies/enemy_move_right_0.png'],
                            state: 'move:right'
                        }
                    ],
                    type: 'enemy',
                    custom: {
                        delta: -1,
                        moving: false
                    }
                },
                background: {
                    image: {
                        src: 'images/background/background_0000.png',
                        repeat: true
                    }
                },
                ground: {
                    image: {
                        src: 'images/tiles/ground.png',
                        repeat: true
                    },
                    type: 'ground'
                },
                box: {
                    image: 'images/tiles/box.png',
                    type: 'box'
                },
                pipeHole: {
                    image: 'images/tiles/pipeHole.png',
                    type: 'pipe-hole'
                },
                pipe: {
                    image: 'images/tiles/pipe.png',
                    type: 'pipe'
                },
                treasure: {
                    images: [
                        {
                            paths: ['images/tiles/treasure.png'],
                            state: 'full'
                        },
                        {
                            paths: ['images/tiles/treasure_empty.png'],
                            state: 'empty'
                        }
                    ],
                    type: 'treasure',
                    custom: {
                        hasCoin: true
                    }
                },
                coin: {
                    obstacle: false,
                    images: [
                        {
                            paths: ['images/tiles/coin-0.png', 'images/tiles/coin-1.png'],
                            state: 'rotate',
                            time: 100
                        }
                    ],
                },
                flagpoleTip: {
                    image: 'images/tiles/flagpoleTip.png'
                },
                flagpole: {
                    obstacle: false,
                    image: {
                        src: 'images/tiles/flagpole.png',
                        repeat: true
                    }
                },
                flag: {
                    images: [
                        {
                            paths: ['images/tiles/flag_up.png', 'images/tiles/flag_down.png'],
                            state: 'flutters',
                            time: 100
                        }
                    ]
                },
                mushroom: {
                    image: 'images/tiles/mushroom.png',
                    type: 'mushroom',
                    custom: {
                        moving: false,
                        delta: 1
                    }
                }
            }

            const map = [
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 1, 5, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            ];

            const enums = {
                box: 1,
                enemy: 2,
                pipeHole: 3,
                pipe: 4,
                treasure: 5
            }

            const DEBUG = false;
            const UNIT = 24;
            const CHARACTER_JUMP_HEIGHT = 100;
            const CHARACTER_JUMP_REBOUND = 10;
            const CHARACTER_JUMP_MULTIPLIER = 0.5;
            const FALL_MULTIPLIER = 0.5;
            const TREASURE_JUMP_HEIGHT = 10;
            const TREASURE_JUMP_MULTIPLIER = 1;
            const TREASURE_FALL_MULTIPLIER = 0.3;
            const ENEMY_JUMP_MULTIPLIER = 1;
            const ENEMY_JUMP_HEIGHT = 20;
            const ENEMY_ROTATE = 180;
            const DESTROY_TIME_DELAY = 500;
            const COIN_JUMP_HEIGHT = 30;
            const MAX_FLAG_LOWERING_HEIGHT = 270;
            const SLIDING_DELTA_MAX_VALUE = 5;
            const SLIDING_DELTA_DEFAULT_VALUE = 1;
            const SLIDING_DELTA_STEP = 0.1;
            const TREASURE_WITH_MUSHROOM = ['treasure-9-21'];
            const grounds = [];
            const obstacles = [];
            const MAX_MAP_LENGTH = (map[0].length - 1) * UNIT;
            const elpy = new Elpy('#field', 500, UNIT * 15); // 500
            const background = elpy.create('background', -10000, -10000, 20000, 20000, options.background);
            const ground01 = elpy.create('ground01', 0, UNIT * 13, UNIT * 69, UNIT * 2, options.ground);
            const ground02 = elpy.create('ground02', UNIT * 71, UNIT * 13, UNIT * 15, UNIT * 2, options.ground);
            const ground03 = elpy.create('ground03', UNIT * 89, UNIT * 13, UNIT * 64, UNIT * 2, options.ground);
            const ground04 = elpy.create('ground04', UNIT * 155, UNIT * 13, UNIT * 69, UNIT * 2, options.ground);
            const flag = createFlag();
            let isFlagLowered = false;
            let coinCounter = 0;

            grounds.push(ground01);
            grounds.push(ground02);
            grounds.push(ground03);
            grounds.push(ground04);
            elpy.add(background);
            elpy.add(grounds);

            loadHiddenObjectTextures();
            spawnObjects();
            
            const character = elpy.create('character', (Math.floor(elpy.width / UNIT) / 2) * UNIT, UNIT * 10, 20, UNIT, options.character);

            elpy.add(character);
            character.move(60, character.y);
            elpy.fixingCamera(character, {
                x: true
            });

            setObstaclesParams();

            character.collision(obstacles);
            character.collision(grounds);
            character.fall(FALL_MULTIPLIER);
            character.on('move', characterOnMove);
            character.on('collision', characterOnCollision);

            elpy.tick(() => {
                if (character.options.custom.slidingDelta > 0) {
                    character.options.custom.slidingDelta -= SLIDING_DELTA_STEP;

                    if (Math.floor(character.options.custom.slidingDelta) < 0) {
                        character.options.custom.slidingDelta = 0;
                    }
                }

                if (character.options.custom.slidingDelta < 0) {
                    character.options.custom.slidingDelta += SLIDING_DELTA_STEP;

                    if (Math.floor(character.options.custom.slidingDelta) > 0) {
                        character.options.custom.slidingDelta = 0;
                    }
                }

                character.move(character.x + Math.floor(character.options.custom.slidingDelta), character.y);
            });

            elpy.key(key => {
                if (!character.options.custom.isMoving) {
                    character.options.custom.slidingDelta = 0;

                    return;
                }

                switch(key) {
                    case 'ArrowUp':
                        character.jump(CHARACTER_JUMP_HEIGHT, CHARACTER_JUMP_MULTIPLIER);
                        
                        break;
                    case 'ArrowLeft':
                        if (character.options.custom.slidingDelta > -SLIDING_DELTA_MAX_VALUE) {
                            if (character.options.custom.slidingDelta === 0) {
                                character.options.custom.slidingDelta = -SLIDING_DELTA_DEFAULT_VALUE;
                            }

                            character.options.custom.slidingDelta -= SLIDING_DELTA_STEP * 2;
                        }
                        
                        break;
                    case 'ArrowRight':
                        if (character.options.custom.slidingDelta < SLIDING_DELTA_MAX_VALUE) {
                            if (character.options.custom.slidingDelta === 0) {
                                character.options.custom.slidingDelta = SLIDING_DELTA_DEFAULT_VALUE;
                            }

                            character.options.custom.slidingDelta += SLIDING_DELTA_STEP * 2;
                        }
                        
                        break;
                }
            });

            elpy.keyup(key => {
                switch(key) {
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        character.state = 'idle';
                        character.animate = false;

                        break;
                }
            });

            elpy.load();

            function spawnObjects() {
                for(let i = 0; i < map.length; i++) {
                    for(let j = 0; j < map[i].length; j++) {
                        if (map[i][j] === enums.box) {
                            spawnBoxes(i, j);
                        }

                        if (map[i][j] === enums.enemy) {
                            spawnEnemies(i, j);
                        }

                        if (map[i][j] === enums.pipeHole) {
                            spawnPipeHoles(i, j);
                        }

                        if (map[i][j] === enums.pipe) {
                            spawnPipe(i, j);
                        }

                        if (map[i][j] === enums.treasure) {
                            spawnTreasures(i, j);
                        }
                    }
                }
            }

            if (DEBUG) {
                elpy.click((x, y) => {
                    const offset = {
                        x: x + elpy.offset.object.offset.x,
                        y: y + elpy.offset.object.offset.y
                    }

                    for(const name in elpy.objects) {
                        const object = elpy.objects[name];

                        if (offset.x > object.x
                        && offset.x < (object.x + object.width)
                        && offset.y > object.y
                        && offset.y < (object.y + object.height)) {
                            console.log(object)
                        }
                    }
                });
            }

            function spawnBoxes(i, j) {
                const box = elpy.create(`box-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, options.box);
                            
                elpy.add(box);
                obstacles.push(box);
            }

            function spawnEnemies(i, j) {
                const enemy = elpy.create(`enemy-${i}-${j}`, UNIT * j, UNIT * i, 15, 13, JSON.parse(JSON.stringify(options.enemy)));
                
                elpy.add(enemy);
                obstacles.push(enemy);
                enemy.on('fall', event => {
                    enemyOnFall(enemy, event);
                });
            }

            function spawnPipeHoles(i, j) {
                const pipeHole = elpy.create(`pipe-hole-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, options.pipeHole);
                            
                elpy.add(pipeHole);
                obstacles.push(pipeHole);
            }

            function spawnPipe(i, j) {
                const pipe = elpy.create(`pipe-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, options.pipe);
                            
                elpy.add(pipe);
                obstacles.push(pipe);
            }

            function spawnTreasures(i, j) {
                const treasure = elpy.create(`treasure-${i}-${j}`, UNIT * j, UNIT * i, UNIT, UNIT, JSON.parse(JSON.stringify(options.treasure)));
                            
                elpy.add(treasure);
                obstacles.push(treasure);
                treasure.collision(getObstaclesEnemies());
                treasure.on('collision', object => {
                    if (object.options.type === 'enemy') {
                        treasureOnCollisionEnemy(treasure, object);
                    }
                });

                rebound(treasure, TREASURE_FALL_MULTIPLIER);
            }

            function characterOnMove() {
                if (character.x > character.track.x) {
                    if (!character.animate) {
                        character.animate = true;
                    }

                    character.state = 'move:right';
                }

                if (character.x < character.track.x) {
                    if (!character.animate) {
                        character.animate = true;
                    }

                    character.state = 'move:left';
                }

                if (character.x <= 0) {
                    character.move(character.x + 1, character.y);
                    
                    character.state = 'idle';
                }

                if (character.x >= MAX_MAP_LENGTH) {
                    character.move(character.x - 1, character.y);
                    
                    character.state = 'idle';
                }

                checkObstaclesInViewport();
            }

            function characterOnCollision(object, side) {
                character.state = 'idle';

                if (['enemy', 'treasure', 'box', 'pipe', 'pipe-hole'].includes(object.options.type)
                && (side === 'left' || side === 'right')) {
                    character.options.custom.slidingDelta = 0;
                }

                if (object.options.type === 'enemy') {
                    checkEnemyCollision(object, side);
                }

                if (object.options.type === 'mushroom') {
                    object.destroy();
                    characterGrowth();
                }

                //
                if (object.name === 'treasure-9-21' && side === 'bottom' && object.state === 'full') {
                    const MAX_DISTANCE = UNIT / 2;
                    let traveledDistance  = 0;

                    object.options.custom.hasCoin = false;

                    checkTreasureCollision(object);

                    const mushroom = elpy.create(`mushroom-${object.name}`, object.x + ((UNIT / 2) / 2), object.y, UNIT / 2, UNIT / 2, JSON.parse(JSON.stringify(options.mushroom)));

                    mushroom.collision(character);
                    mushroom.collision(obstacles);
                    mushroom.collision(grounds);
                    character.collision(mushroom);
                    elpy.add(mushroom);
                    
                    elpy.tick(() => {
                        if (traveledDistance >= MAX_DISTANCE) {
                            mushroom.fall(FALL_MULTIPLIER);

                            moveObstacle(mushroom);

                            return false;
                        }

                        traveledDistance++;
                        mushroom.y -= 1;
                    });
                    
                    mushroom.on('collision', (object, side) => {
                        if (object === character) {
                            mushroom.destroy();

                            characterGrowth();
                        }

                        if (side === 'left') {
                            mushroom.options.custom.delta = -1;
                            mushroom.state = 'move:left';
                        }

                        if (side === 'right' || mushroom.x >= MAX_MAP_LENGTH) {
                            mushroom.options.custom.delta = 1;
                            mushroom.state = 'move:right';
                        }
                    });

                    mushroom.on('move', () => {
                        if (mushroom.y >= elpy.height) {
                            mushroom.destroy();
                        }
                    });
                }
                //

                if (object.options.type === 'treasure' && side === 'bottom' && object.state === 'full') {
                    checkTreasureCollision(object);
                }

                if (object.name === 'flagpole') {
                    if (!isFlagLowered) {
                        isFlagLowered = true;

                        character.stop();

                        character.options.custom.isMoving = false;

                        lowerFlag();
                        lowerCharacter();
                    }
                }
            }

            function characterGrowth() {
                character.y = character.y - character.height;
                character.height = character.height * 2;
            }

            function enemyOnFall(enemy, event) {
                if (elpy.checkObjectInViewport(enemy)) {
                    event.resume();
                } else {
                    event.pause();
                }
                
                if (enemy.ghost) {
                    event.stop();
                }
            }

            function treasureOnCollisionEnemy(treasure, object) {
                object.ghost = true;
                
                object.jump(ENEMY_JUMP_HEIGHT, ENEMY_JUMP_MULTIPLIER);
                object.rotate(ENEMY_ROTATE);
                treasure.jump(TREASURE_JUMP_HEIGHT, TREASURE_JUMP_MULTIPLIER, true);
                
                delayedDestroy(object, DESTROY_TIME_DELAY);
            }

            function getObstaclesEnemies() {
                return obstacles.filter(obstacle => obstacle.options.type === 'enemy');
            }

            function setObstaclesParams() {
                obstacles.forEach(obstacle => {
                    if (obstacle.options.type === 'enemy') {
                        obstacle.on('collision', (object, side) => {
                            if (side === 'left') {
                                obstacle.options.custom.delta = -1;
                                obstacle.state = 'move:left';
                            }

                            if (side === 'right' || obstacle.x >= MAX_MAP_LENGTH) {
                                obstacle.options.custom.delta = 1;
                                obstacle.state = 'move:right';
                            }
                        });

                        obstacle.on('move', () => {
                            if (obstacle.y >= elpy.height) {
                                obstacle.destroy();
                            }
                        });

                        obstacle.collision(obstacles);
                        obstacle.collision(character);
                        obstacle.collision(grounds);
                        obstacle.fall(FALL_MULTIPLIER);
                    }
                });
            }

            function moveObstacle(obstacle) {
                if (!obstacle.options.custom.moving) {
                    obstacle.options.custom.moving = true;

                    elpy.tick(() => {
                        if (!elpy.checkObjectInViewport(obstacle) || obstacle.ghost) {
                            obstacle.options.custom.moving = false;

                            return false;
                        }

                        obstacle.move(obstacle.x + obstacle.options.custom.delta, obstacle.y);
                    });
                }
            }

            function checkObstaclesInViewport() {
                obstacles.forEach(obstacle => {
                    if (obstacle.options.type === 'enemy') {
                        if (elpy.checkObjectInViewport(obstacle)) {
                            moveObstacle(obstacle);
                        } else {
                            obstacle.options.custom.moving = false;
                        }
                    }
                });
            }

            function checkEnemyCollision(object, side) {
                if (side === 'top') {
                    elpy.nextTick(() => {
                        character.jump(CHARACTER_JUMP_REBOUND, CHARACTER_JUMP_MULTIPLIER);
                    });

                    const height = object.height / 2;

                    object.height = height;
                    object.y = object.y + height;
                    object.ghost = true;

                    delayedDestroy(object, DESTROY_TIME_DELAY);
                }
            }

            function checkTreasureCollision(object) {
                object.jump(TREASURE_JUMP_HEIGHT, TREASURE_JUMP_MULTIPLIER);

                object.state = 'empty';
                
                if (object.options.custom.hasCoin) {
                    dropCoin(object);
                }
            }

            function rebound(object, fallMultiplier = 0.1) {
                const y = object.y;

                object.on('fall', event => {
                    if (object.y >= y) {
                        object.move(object.x, y);
                        event.stop();
                    }
                });

                object.on('jump', event => {
                    if (object.y === object.track.y) {
                        event.stop();
                        object.fall(fallMultiplier)
                    }
                });
            }

            function dropCoin(object) {
                const coin = elpy.create('coin' + coinCounter, object.x + 3, object.y - object.height, 18, 18, options.coin);

                coinCounter++;

                coin.on('jump', event => {
                    if (coin.y === coin.track.y) {
                        event.stop();

                        delayedDestroy(coin, DESTROY_TIME_DELAY);
                    }
                });

                coin.animate = true;

                elpy.add(coin);
                coin.jump(COIN_JUMP_HEIGHT);
            }

            function delayedDestroy(object, time) {
                setTimeout(() => {
                    object.destroy();
                }, time);
            }

            function loadHiddenObjectTextures() {
                const coin = elpy.create('coin', 0, 0, 0, 0, options.coin);

                elpy.add(coin);
                elpy.on('load', () => {
                    coin.destroy();
                });
            }

            function createFlag() {
                const flagpoleTip = elpy.create('flagpole-tip', (UNIT * 198) + 9, (UNIT * 3), 6, 4, options.flagpoleTip);
                const flagpole = elpy.create('flagpole', (UNIT * 198) + 9, (UNIT * 3) + 4, 6, (UNIT * 9) - 4, options.flagpole);
                const flag = elpy.create('flag', (UNIT * 198) + 9, (UNIT * 3) + 4, 18, 18, options.flag);

                flag.animate = true;
                
                elpy.add(flagpoleTip);
                elpy.add(flagpole);
                elpy.add(flag);

                obstacles.push(flagpole);

                return flag;
            }

            function lowerFlag() {
                if (flag.y >= MAX_FLAG_LOWERING_HEIGHT) {
                    return;
                }

                let y = flag.y;

                elpy.tick(() => {
                    if (y >= MAX_FLAG_LOWERING_HEIGHT) {
                        return false;
                    }

                    flag.move(flag.x, y);

                    y += 2;
                })
            }

            async function lowerCharacter() {
                removeCollisionWithCharacter();

                await moveCharacterDown();
                await moveCharacterRight();
                await moveCharacterToCastle();
            }

            function removeCollisionWithCharacter() {
                character.obstacles.forEach(obstacle => {
                    if (obstacle.name.includes('box')) {
                        character.removeCollision(obstacle);
                    }
                });
            }

            function moveCharacterDown() {
                return new Promise(resolve => {
                    elpy.tick(() => {
                        if (character.y >= 264) {
                            resolve();

                            return false;
                        }

                        character.move(character.x, character.y + 2);
                    });
                });
            }

            function moveCharacterRight() {
                return new Promise(resolve => {
                    elpy.tick(() => {
                        if (character.x >= 4766) {
                            resolve();

                            return false;
                        }

                        character.move(character.x + 1, character.y);
                    })
                });
            }

            function moveCharacterToCastle() {
                return new Promise(resolve => {
                    character.fall();
                    character.jump(10, 0.1, true);

                    elpy.tick(() => {
                        if (character.x >= 4898) {
                            resolve();
                            
                            return false;
                        }

                        character.move(character.x + 1, character.y);
                    });
                });
            }
        }

        init();

        mobileControls();

        function mobileControls() {
            const field = document.querySelector('#field');
            const controls = document.querySelector('.js-controls');
            const controlsArrowLeft = document.querySelector('.js-controls-arrow-left');
            const controlsArrowRight = document.querySelector('.js-controls-arrow-right');
            const controlsButtonJump = document.querySelector('.js-controls-button-jump');
            const play = document.querySelector('.js-play');
            const playButton = document.querySelector('.js-play-button');
            
            controlsArrowLeft.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ArrowLeft'}));
            });

            controlsArrowLeft.addEventListener('touchend', () => {
                document.dispatchEvent(new KeyboardEvent('keyup',{'code':'ArrowLeft'}));
            });

            controlsArrowRight.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ArrowRight'}));
            });

            controlsArrowRight.addEventListener('touchend', () => {
                document.dispatchEvent(new KeyboardEvent('keyup',{'code':'ArrowRight'}));
            });

            controlsButtonJump.addEventListener('touchstart', () => {
                document.dispatchEvent(new KeyboardEvent('keydown',{'code':'ArrowUp'}));
            });

            controlsButtonJump.addEventListener('touchend', () => {
                document.dispatchEvent(new KeyboardEvent('keyup',{'code':'ArrowUp'}));
            });

            if (window.outerWidth <= 768) {
                field.style.display = 'none';
            }

            playButton.addEventListener('click', () => {
                if (window.outerWidth <= 768) {
                    document.body.requestFullscreen();
                    window.addEventListener('fullscreenchange', () => {
                        screen.orientation.lock("landscape-primary");
                        
                        window.addEventListener('orientationchange', () => {
                            play.style.display = 'none';
                            controls.style.display = 'flex';
                            field.style.display = 'block';
                            init();
                            // elpy._ctx.canvas.width = Math.floor(window.outerWidth / (elpy._ctx.canvas.clientWidth / window.outerWidth));
                            // elpy.offset.object.offset.x += Math.floor((elpy._ctx.canvas.clientWidth - elpy._ctx.canvas.width) / 2);
                            // elpy.offset.x -= Math.floor((elpy._ctx.canvas.clientWidth - elpy._ctx.canvas.width) / 2);
                        });
                    }); 
                }
            });
        }
    </script>
</body>
</html>